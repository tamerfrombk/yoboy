#!/usr/bin/env python3

#
# generate_ops.py 
#
# Author: Tamer Aly (2019)
#
# This script generates the opcodes table used by the emulator.
#
#

from sys import argv
import json

FILE_HEADER = '''
/*
This file was autogenerated by the instruction generator script.
*/
'''

HEADER_PREFIX = '''
#pragma once

#include <unordered_map>
#include <string>
#include <cstdint>

namespace yb {

struct Instruction {
    uint8_t op;
    std::string mnemonic;
    uint8_t length;
    uint8_t cycles;

    bool isPrefix() const;

    bool isJump() const;

    bool isCall() const;

    bool isReturn() const;

    bool isRestart() const;
};

extern std::unordered_map<uint8_t, yb::Instruction> INSTRUCTIONS;
extern std::unordered_map<uint8_t, yb::Instruction> PREFIXED_INSTRUCTIONS;

}
'''

SOURCE_PREFIX = '''
#include "ops.h"

bool yb::Instruction::isPrefix() const
{
    return op == 0xCB;
}

bool yb::Instruction::isJump() const
{
    return op == 0xC3 // JP nn
        || op == 0xC2 || op == 0xCA || op == 0xD2 || op == 0xDA // JP cc, nn
        || op == 0xE9 // JP (HL)
        || op == 0x18 // JR n
        || op == 0x20 || op == 0x28 || op == 0x30 || op == 0x38; // JP cc, n
}

bool yb::Instruction::isCall() const
{
    return op == 0xCD
        || op == 0xC4
        || op == 0xCC
        || op == 0xD4
        || op == 0xDC;
}

bool yb::Instruction::isReturn() const
{
    return op == 0xC9
        || op == 0xC0
        || op == 0xC8
        || op == 0xD0
        || op == 0xD8
        || op == 0xD9; // RETI
}

bool yb::Instruction::isRestart() const
{
    return op == 0xC7
        || op == 0xCF
        || op == 0xD7
        || op == 0xDF
        || op == 0xE7
        || op == 0xEF
        || op == 0xF7
        || op == 0xFF;
}
'''

class Instruction():

    def __init__(self, op, mnemonic, length, cycles, operands):
        self.op = op 
        self.mnemonic = mnemonic 
        self.length = length
        self.cycles = cycles
        self.operands = operands

    def __repr__(self):
        return '{{ {} , Instruction{{ {}, "{} {}", {}, {} }} }}'\
                .format(self.op, self.op, self.mnemonic, self.operands, self.length, self.cycles)

def build_operands(obj):
    operands = ""

    if 'operand1' in obj:
        operands += obj['operand1'].upper()

    if 'operand2' in obj:
        operands += ','
        operands += obj['operand2'].upper()

    arg_map = {
        "D8"  : "BYTE",
        "D16" : "WORD",
        "R8"  : "SBYTE",
        "A8"  : "BYTE",
        "A16" : "WORD"
    }

    for (k, v) in arg_map.items():
        if k in operands:
            operands = operands.replace(k, v)

    return operands

def create_instruction(obj):
    op = obj['addr'].upper()
    mnemonic = obj['mnemonic'].upper()
    length = obj['length']
    cycles = obj['cycles'][0]

    operands = build_operands(obj)

    return Instruction(op, mnemonic, length, cycles, operands)

def generate_instructions(path):
    instruction_map = {}
    with open(path, 'r') as f:
        root = json.load(f)
        types = ['unprefixed', 'cbprefixed']
        for t in types:
            prefix_type = root[t]

            instructions = []
            for obj in prefix_type:
                instructions.append(create_instruction(prefix_type[obj]))

            instruction_map[t] = instructions
            
    return instruction_map

def write_header(instructions):
    with open('ops.h', 'w') as f:
        f.write(FILE_HEADER)
        f.write(HEADER_PREFIX)

def write_instruction_list(file, name, list):
    map_declaration = 'std::unordered_map<uint8_t, yb::Instruction> yb::{}'.format(name)
    file.write(map_declaration + ' = {\n')
    for inst in list:
        file.write('\t{},\n'.format(inst))
    file.write('};\n')

def write_source(instructions):
    with open('ops.cc', 'w') as f:
        f.write(FILE_HEADER)
        f.write(SOURCE_PREFIX)
        f.write('\n')

        write_instruction_list(f, 'INSTRUCTIONS', instructions['unprefixed'])
        f.write('\n')
        write_instruction_list(f, 'PREFIXED_INSTRUCTIONS', instructions['cbprefixed'])

def main():
    argc = len(argv)
    if argc != 2:
        print("Missing required JSON file!")
        exit()

    _, path = argv

    instructions = generate_instructions(path)

    write_header(instructions)
    write_source(instructions)

if __name__ == '__main__':
    main()
